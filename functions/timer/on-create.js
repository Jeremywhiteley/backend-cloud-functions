/**
 * Copyright (c) 2018 GrowthFile
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 */


'use strict';


const {
  db,
  rootCollections,
} = require('../admin/admin');
const {
  dateFormats,
  httpsActions,
  reportNames,
  sendGridTemplateIds,
} = require('../admin/constants');
const {
  alphabetsArray,
} = require('../firestore/recipients/report-utils');
const fs = require('fs');
const env = require('../admin/env');
const sgMail = require('@sendgrid/mail');
const momentTz = require('moment-timezone');
const xlsxPopulate = require('xlsx-populate');

sgMail.setApiKey(env.sgMailApiKey);

const handleUserStatusReport = (locals) => {
  const {
    worksheet,
    counterDocsQuery,
    initDocsQuery,
    profilesDocsQuery,
  } = locals;

  const sheet1 = worksheet.addSheet('USER STATUS REPORT');
  sheet1.row(1).style('bold', true);

  const {
    totalUsers,
  } = counterDocsQuery.docs[0].data();

  const {
    installedToday,
    usersAdded,
  } = initDocsQuery.docs[0].data();

  sheet1.cell('A1').value('TOTAL USERS');
  sheet1.cell('A2').value(totalUsers);

  sheet1.cell('B1').value('USERS ADDED YESTERDAY');
  sheet1.cell('B2').value(usersAdded);

  sheet1.cell('C1').value('ACTIVE YESTERDAY');
  sheet1.cell('C2').value(profilesDocsQuery.size);

  sheet1.cell('D1').value('INSTALLED YESTERDAY');
  sheet1.cell('D2').value(installedToday);

  return locals;
};


const handleActivityStatusReport = (locals) => {
  const {
    worksheet,
    counterDocsQuery,
    initDocsQuery,
    activityTemplatesQuery,
  } = locals;

  const sheet2 = worksheet.addSheet('ACTIVITY STATUS REPORT');
  sheet2.row(1).style('bold', true);
  sheet2.column(1).style('bold', true);

  const {
    templateUsageObject,
    activitiesAddedToday,
    commentApi,
    createApi,
    changeStatusApi,
    shareApi,
    updateApi,
    withAdminApi,
    withSupport,
  } = initDocsQuery.docs[0].data();

  const getNumber = (templateName, action) => {
    if (!templateUsageObject[templateName]
      || !templateUsageObject[templateName][action]) {
      return '(not used)';
    }

    return templateUsageObject[templateName][action];
  };

  [
    'TOTAL',
    'USING ADMIN API',
    'AUTO GENERATED',
    'WITH SUPPORT',
    'CREATE',
    'UPDATE',
    'CHANGE STATUS',
    'SHARE',
    'COMMENT',
  ].forEach((header, index) => {
    const cellIndex = `${alphabetsArray[index + 1]}1`;

    sheet2.cell(cellIndex).value(header);
  });

  // RaxiOZTTUDXGuWzvaFda
  const counterDoc = counterDocsQuery.docs[0];

  const totalActivities = counterDoc.get('totalActivities');
  const totalCreatedWithAdminApi = counterDoc.get('totalCreatedWithAdminApi');
  const totalAutoGeneratedActivities = counterDoc.get('totalAutoGeneratedActivities');
  const totalCreatedWithSupport = counterDoc.get('totalCreatedWithSupport');
  const adminApiMap = counterDoc.get('adminApiMap');
  const autoGeneratedMap = counterDoc.get('autoGeneratedMap');
  const supportMap = counterDoc.get('supportMap');

  const totalByTemplateMap = counterDoc.get('totalByTemplateMap');

  sheet2.cell('A1').value('');
  sheet2.cell('A2').value('');

  sheet2.cell('B1').value('TOTAL');

  // total activities
  sheet2.cell('B2').value(totalActivities);

  // total created using admin api
  sheet2.cell('C2').value(totalCreatedWithAdminApi);

  // auto generated -> admin + subscription + subscription of template with canEditRule ADMIN
  sheet2.cell('D2').value(totalAutoGeneratedActivities);

  // auto generated (created)
  sheet2.cell('E2').value(totalCreatedWithSupport);

  // created with support
  sheet2.cell('F2').value(createApi);

  // client update api
  sheet2.cell('G2').value(updateApi);

  // client change status api
  sheet2.cell('H2').value(changeStatusApi);

  // client create api
  sheet2.cell('I2').value(shareApi);

  // client comment api
  sheet2.cell('J2').value(commentApi);

  activityTemplatesQuery.docs.forEach((doc, index) => {
    const templateName = doc.get('name');
    const columnIndex = index + 3;

    sheet2.cell(`A${columnIndex}`).value(templateName.toUpperCase());

    // totalByTemplateMap
    sheet2.cell(`B${columnIndex}`).value(totalByTemplateMap[templateName] || 0);

    // adminApiMap
    sheet2.cell(`C${columnIndex}`).value(adminApiMap[templateName] || 0);

    // autoGeneratedMap
    sheet2.cell(`D${columnIndex}`).value(autoGeneratedMap[templateName] || 0);

    // supportMap
    sheet2.cell(`E${columnIndex}`).value(supportMap[templateName] || 0);

    // create
    sheet2
      .cell(`F${columnIndex}`)
      .value(getNumber(templateName, httpsActions.create));

    // update
    sheet2
      .cell(`G${columnIndex}`)
      .value(getNumber(templateName, httpsActions.update));

    // change status
    sheet2
      .cell(`H${columnIndex}`)
      .value(getNumber(templateName, httpsActions.changeStatus));

    // share
    sheet2
      .cell(`I${columnIndex}`)
      .value(getNumber(templateName, httpsActions.share));

    // comment
    sheet2
      .cell(`J${columnIndex}`)
      .value(getNumber(templateName, httpsActions.comment));
  });

  return locals;
};


const handleDailyStatusReport = () => {
  const fileName = `Growthfile Daily Status Report.xlsx`;
  const filePath = `/tmp/${fileName}`;
  const yesterdayStartMoment =
    momentTz()
      .subtract(1, 'days')
      .startOf('days');
  const yesterdayMomentObject = yesterdayStartMoment.toObject();
  const standardDateString = momentTz().format(dateFormats.DATE);
  const messageObject = {
    templateId: sendGridTemplateIds.dailyStatusReport,
    to: env.instantEmailRecipientEmails,
    from: env.systemEmail,
    attachments: [],
    'dynamic_template_data': {
      date: standardDateString,
      subject: `Daily Status Report_Growthfile_${standardDateString}`,
    },
  };

  const locals = {};

  return Promise
    .all([
      rootCollections
        .inits
        .where('report', '==', 'counter')
        .limit(1)
        .get(),
      rootCollections
        .inits
        .where('report', '==', reportNames.DAILY_STATUS_REPORT)
        .where('date', '==', yesterdayMomentObject.date)
        .where('month', '==', yesterdayMomentObject.months)
        .where('year', '==', yesterdayMomentObject.years)
        .limit(1)
        .get(),
      rootCollections
        .profiles
        .where('lastQueryFrom', '>=', yesterdayStartMoment.unix() * 1000)
        .get(),
      rootCollections
        .activityTemplates
        .orderBy('name', 'asc')
        .get(),
      xlsxPopulate
        .fromBlankAsync(),
    ])
    .then((result) => {
      const [
        counterDocsQuery,
        initDocsQuery,
        profilesDocsQuery,
        activityTemplatesQuery,
        worksheet,
      ] = result;

      locals.worksheet = worksheet;
      locals.counterDocsQuery = counterDocsQuery;
      locals.initDocsQuery = initDocsQuery;
      locals.profilesDocsQuery = profilesDocsQuery;
      locals.activityTemplatesQuery = activityTemplatesQuery;

      return handleUserStatusReport(locals);
    })
    .then((locals) => handleActivityStatusReport(locals))
    .then((locals) => {
      locals.worksheet.deleteSheet('Sheet1');

      return locals;
    })
    .then((locals) => locals.worksheet.toFileAsync(filePath))
    .then(() => {
      messageObject.attachments.push({
        fileName,
        content: fs.readFileSync(filePath).toString('base64'),
        type: 'text/csv',
        disposition: 'attachment',
      });

      return sgMail.sendMultiple(messageObject);
    })
    .catch(console.error);
};

const sendErrorReport = () => {
  const {
    dateFormats,
  } = require('../admin/constants');
  const momentTz = require('moment-timezone');

  const today = momentTz().subtract(1, 'days');

  return rootCollections
    .errors
    .where('date', '==', today.date())
    .where('month', '==', today.month())
    .where('year', '==', today.year())
    .get()
    .then((docs) => {
      if (docs.empty) {
        // No errors yesterday
        return Promise.resolve();
      }

      let messageBody = '';

      docs.docs.forEach((doc, index) => {
        const {
          affectedUsers,
          bodyObject,
          deviceObject,
          message,
        } = doc.data();

        const str = `
        <h2>${index + 1}. Error message: ${message} | ${doc.id}</h2>
        <h3>Affected Users</h3>
        <p>${Object.keys(affectedUsers)}</p>
        <h3>Error Body</h3>
        <p><pre>${JSON.stringify(bodyObject, ' ')}</pre></p>
        <h3>Error Device</h3>
        <p><pre>${JSON.stringify(deviceObject, ' ')}</pre></p>
        <hr>
        `;

        messageBody += `${str}\n\n`;
      });


      const subject =
        `${process.env.GCLOUD_PROJECT}`
        + ` Frontend Errors ${today.format(dateFormats.DATE)}`;

      const sgMail = require('@sendgrid/mail');
      const env = require('../admin/env');
      sgMail.setApiKey(env.sgMailApiKey);

      console.log('sending mail');

      return sgMail.send({
        subject,
        to: env.instantEmailRecipientEmails,
        from: { name: 'Growthile', email: 'gcloud@growthfile.com' },
        html: messageBody,
      });
    })
    .catch(console.error);
};


module.exports = (doc) => {
  if (doc.get('sent')) {
    // Helps to check if email is sent already. 
    // Cloud functions sometimes trigger multiple times
    // For a single write.
    console.log('double trigger', 'sent', doc.get('sent'));

    return Promise.resolve();
  }

  return Promise
    .all([
      rootCollections
        .recipients
        .get(),
      handleDailyStatusReport(),
      sendErrorReport(),
      doc
        .ref
        .set({
          sent: true,
        }, {
            merge: true,
          }),
    ])
    .then((result) => {
      const [
        recipientsQuery,
      ] = result;

      const messages = [];

      env
        .instantEmailRecipientEmails
        .forEach((email) => {
          const html = `
        <p>Date (DD-MM-YYYY): ${doc.id}</p>
        <p>Timestamp: ${new Date(doc.get('timestamp')).toJSON()}</p>
        `;

          messages.push({
            html,
            cc: env.systemEmail,
            subject: 'FROM Timer function',
            to: email,
            from: env.systemEmail,
          });
        });

      console.log({ messages });

      const batch = db.batch();
      const dateString = new Date().toDateString();

      recipientsQuery
        .forEach((doc) => batch.set(doc.ref, { dateString }, { merge: true }));

      return Promise
        .all([
          sgMail
            .sendMultiple(messages),
          batch
            .commit(),
        ]);
    })
    .catch(console.error);
};
